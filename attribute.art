(* gcdAttribute.art GCD in attribute-actions with native Java actions - 5 CFG phrase level rules and 3 CFG lexical rules*)
(* Use ofplugin in expressions requires return result that can be cast to int *)
//!interpreter attributeAction
!support
!! import java.util.Map; import java.util.HashMap; !!
!! Map<String, Object> variables = new HashMap<>(); 
   Map<String, AbstractAttributeBlock> procedures = new HashMap<>(); !!

statements ::= statement statements
| statement !! System.out.println("Final variable map " + variables); !! 

statement ::= 
  ID ':=' e0 ';' !! variables.put(ID1.v, e01.v); !!     // assignment 
| ID ':=' l0 ';' !! variables.put(ID1.v, l01.v); !!     // assignment 
| 'if' e0 'then' statement!< 'else' statement!<                // if statement 
  !! if (e01.v != 0) interpret(statement1); else interpret(statement2); !! 
| 'while' e0!< 'do' statement!<                         // while statement 
  !! interpret(e01); while (e01.v != 0) { interpret(statement1); interpret(e01); } !! 
| 'plugin' '(' STRING_SQ ')' ';' !! plugin(STRING_SQ1.v); !!
| 'plugin' '(' STRING_SQ ',' e0 ')' ';'!! plugin(STRING_SQ1.v, e01.v); !!
| 'plugin' '(' STRING_SQ ',' e0 ',' e0 ')' ';' !! plugin(STRING_SQ1.v, e01.v, e02.v); !!
| 'plugin' '(' STRING_SQ  ',' e0 ',' e0 ',' e0 ')' ';' !! plugin(STRING_SQ1.v, e01.v, e02.v, e03.v); !!

e0 <v:int> ::= 
  e1         !! e0.v = e11.v; !! 
| e1 '>'  e1 !! e0.v = e11.v >  e12.v ? 1 : 0; !!       // Greater than
| e1 '<'  e1 !! e0.v = e11.v <  e12.v ? 1 : 0; !!       // Less than
| e1 '>=' e1 !! e0.v = e11.v >= e12.v ? 1 : 0; !!       // Greater than or equals
| e1 '<=' e1 !! e0.v = e11.v <= e12.v ? 1 : 0; !!       // Less than or equals
| e1 '==' e1 !! e0.v = e11.v == e12.v ? 1 : 0; !!       // Equal to
| e1 '!=' e1 !! e0.v = e11.v != e12.v ? 1 : 0; !!       // Not equal to

e1 <v:int>  ::= 
  e2         !! e1.v = e21.v; !! 
| e1 '+' e2  !! e1.v = e11.v + e21.v; !!                // Add 
| e1 '-' e2  !! e1.v = e11.v - e21.v; !!                // Subtract

e2  <v:int> ::= 
  e3         !! e2.v= e31.v; !! 
| e2 '*' e3  !! e2.v = e21.v * e31.v; !!                // Multiply 
| e2 '/' e3  !! e2.v = e21.v / e31.v; !!                // Divide 
| e2 '%' e3  !! e2.v = e21.v % e31.v; !!                // Mod 

e3  <v:int> ::= 
  e4         !! e3.v = e41.v; !!
| '+' e3     !! e3.v = e31.v; !!                         // Posite 
| '-' e3     !! e3.v = -e31.v; !!                        // Negate 

e4  <v:int> ::= 
  e5         !! e4.v = e51.v; !! 
| e5 '**' e4 !! e4.v = (int) Math.pow(e51.v, e41.v); !! // Exponentiate

e5  <v:int> ::= 
  INTEGER !! e5.v = INTEGER1.v; !!                       // Integer literal
| '(' e1 !! e5.v = e11.v; !! ')'                        // Parenthesised expression
| 'plugin' '(' STRING_SQ ',' e0 ')' !! e5.v = (int) plugin(STRING_SQ1.v, e01.v); !!

l0 <v:boolean> ::=
  l1 !! l0.v = l11.v; !!
| l1 '&&' l1 !! l0.v = l11.v && l12.v ? true : false; !!
| l1 '||' l1 !! l0.v = l11.v || l12.v ? true : false; !!
| '!'l1      !! l0.v = !l11.v ? true : false; !!

l1 <v:boolean> ::=
  BOOLEAN !! l1.v = BOOLEAN1.v; !!
// Lexical rules
ID <v:String>        ::= &ID !! ID.v = lexeme(); !!  
STRING_SQ <v:String> ::= &STRING_SQ !! STRING_SQ.v = lexemeCore().translateEscapes(); !!
INTEGER <v:int>      ::= &INTEGER   !! INTEGER.v = Integer.parseInt(lexeme()); !!
BOOLEAN <v:boolean>  ::= 'true' !! BOOLEAN.v = true; !! | 'false' !! BOOLEAN.v = false; !!

//!generate actions 
!try "a := 10 > 20;"
!try "a := 10 < 20;"
!try "a := 10 >= 20;"
!try "a := 10 <= 20;"
!try "a := 10 == 20;"
!try "a := 10 != 20;"

!try "b := 10 + 2;"
!try "b := 10 - 2;"
!try "b := 10 * 2;"
!try "b := 10 / 2;"
!try "b := 10 % 2;"
!try "b := 10 ** 2;"

!try "c:= 3 + 4 * 5;" 
!try "c:= (3 + 4) * 5;" 
!try "c:= 2**2;"
!try "c:= (8 + (6 - 2**2)) / 5;"
!try "c:= ((8 + 6) - 2**2) / 5;"
!try "c:= -5;" 
!try "c:= --5;"

!try "d:= true;"
!try "d:= false;"
!try "d:= !true;"
!try "d:= !false;"
!try "d:= true && false;"
!try "d:= true || false;"


// !try "a := 6; b := 9; while a != b do if a > b then a := a - b; else b := b - a; gcd := a; plugin('init'); plugin('ding');"
