(* gcdAttribute.art GCD in attribute-actions with native Java actions - 5 CFG phrase level rules and 3 CFG lexical rules*)
(* Use ofplugin in expressions requires return result that can be cast to int *)
//!interpreter attributeAction
!support
!! import java.util.Map; import java.util.HashMap; !!
!! Map<String, Object> variables = new HashMap<>(); 
   Map<String, AbstractAttributeBlock> procedures = new HashMap<>(); !!

text ::= statements                                     !! System.out.println("Final variable map " + variables); !!
statements ::= statement | statement statements

statement ::= 
  ID ':=' e0 ';'                                        !! variables.put(ID1.v, e01.v); !!     // assignment 
| 'if' e0 'then' statement!< elseOpt!<                  !! if ((int) e01.v != 0) interpret(statement1); else interpret(elseOpt1); !! 
| 'while' e0!< 'do' statement!<                         !! interpret(e01); while ((int) e01.v != 0) { interpret(statement1); interpret(e01); } !! 
| 'plugin' '(' STRING_SQ ')' ';'                        !! plugin(STRING_SQ1.v); !!
| 'plugin' '(' STRING_SQ ',' e0 ')' ';'                 !! plugin(STRING_SQ1.v, e01.v); !!
| 'plugin' '(' STRING_SQ ',' e0 ',' e0 ')' ';'          !! plugin(STRING_SQ1.v, e01.v, e02.v); !!
| 'plugin' '(' STRING_SQ  ',' e0 ',' e0 ',' e0 ')' ';'  !! plugin(STRING_SQ1.v, e01.v, e02.v, e03.v); !!
| 'print' '(' printElements ')' ';'                    (* print statement *)

| 'procedure' ID statement!< !! procedures.put(ID1.v, statement1); !!
| 'call' ID ';' !! interpret(procedures.get(ID1.v)); !! 

| '{' statements '}'                                    (* compound statement *)

elseOpt ::= 'else' statement | #     

printElements ::= 
  STRING_SQ !! System.out.print(STRING_SQ1.v); !! 
| STRING_SQ !! System.out.print(STRING_SQ1.v); !! ',' printElements 
| e0 !! System.out.print(e01.v); !! 
| e0 !! System.out.print(e01.v); !! ',' printElements  

e0 <v:Object> ::=
  e1                                                    !! e0.v = (int) e11.v; !! 
| e1 '>'  e1                                            !! e0.v = (int) e11.v >  (int) e12.v ? 1 : 0; !!       // Greater than
| e1 '<'  e1                                            !! e0.v = (int) e11.v <  (int) e12.v ? 1 : 0; !!       // Less than
| e1 '>=' e1                                            !! e0.v = (int) e11.v >= (int) e12.v ? 1 : 0; !!       // Greater than or equals
| e1 '<=' e1                                            !! e0.v = (int) e11.v <= (int) e12.v ? 1 : 0; !!       // Less than or equals
| e1 '==' e1                                            !! e0.v = (int) e11.v == (int) e12.v ? 1 : 0; !!       // Equal to
| e1 '!=' e1                                            !! e0.v = (int) e11.v != (int) e12.v ? 1 : 0; !!       // Not equal to

e1 <v:Object>  ::= 
  e2                                                    !! e1.v = (int) e21.v; !! 
| e1 '+' e2                                             !! e1.v = (int) e11.v + (int) e21.v; !!                // Add 
| e1 '-' e2                                             !! e1.v = (int) e11.v - (int) e21.v; !!                // Subtract

e2  <v:Object> ::= 
  e3                                                    !! e2.v = (int) e31.v; !! 
| e2 '*' e3                                             !! e2.v = (int) e21.v * (int) e31.v; !!                // Multiply 
| e2 '/' e3                                             !! e2.v = (int) e21.v / (int) e31.v; !!                // Divide 
| e2 '%' e3                                             !! e2.v = (int) e21.v % (int) e31.v; !!                // Mod 

e3  <v:Object> ::= 
  e4                                                    !! e3.v = (int) e41.v; !!
| '+' e3                                                !! e3.v = (int) e31.v; !!                         // Posite 
| '-' e3                                                !! e3.v = - (int) e31.v; !!                        // Negate 

e4  <v:Object> ::= 
  e5                                                    !! e4.v = (int) e51.v; !! 
| e5 '**' e4                                            !! e4.v = (int) Math.pow((int) e51.v, (int) e41.v); !! // Exponentiate

e5  <v:Object> ::= 
  INTEGER                                               !! e5.v = INTEGER1.v; !!                       // Integer literal
| REAL                                                  !! e5.v = REAL1.v; !!                       // Integer literal
| ID                                                    !! Object obj = variables.get(ID1.v); if (obj instanceof Integer i) {e5.v = i;} else if (obj instanceof Double d) {e5.v = d;}  !!       // Variable access 
| '(' e1                                                !! e5.v = e11.v; !! ')'                        // Parenthesised expression 
| 'plugin' '(' STRING_SQ ',' e0 ')'                     !! e5.v = (int) plugin(STRING_SQ1.v, e01.v); !!

// Lexical rules
ID <v:String>        ::= &ID                            !! ID.v = lexeme(); !!  
STRING_SQ <v:String> ::= &STRING_SQ                     !! STRING_SQ.v = lexemeCore().translateEscapes(); !!
INTEGER <v:int>      ::= &INTEGER                       !! INTEGER.v = Integer.parseInt(lexeme()); !!
REAL <v:double>      ::= &REAL                          !! REAL.v = Double.parseDouble(lexeme()); !!
//!generate actions 
!try "a := 6; b := 9; while a != b do if a > b then a := a - b; else b := b - a; gcd := a; plugin('init'); plugin('ding');"
!try "a := 2; b := 5;"
!try "x := a + b;"
!try "x := a - b;"
!try "x := a * b;"
!try "x := a / b;"
!try "x := a % b;"
!try "x := a ** b;"

!try "print('Result: ', (3+4)*2, '\n');"
!try "x := 3;"

!try "
procedure sub {
  print('Hello from a procedure\n'); 
}


x := 3;
while x > 0 do { 
  print('x is ', x, '\n'); 
  x := x -1; 
}

call sub;
"